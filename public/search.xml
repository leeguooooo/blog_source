<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[作用域和闭包]]></title>
    <url>%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[目录 目录 前言 执行上下文 this 作用域 作用域链 闭包 闭包的概念 闭包的用途 使用闭包的注意事项 参考 前言作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目： 题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就alert弹出其编号 1234567&lt;ul&gt; &lt;li&gt;编号1，点击我请弹出1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 一般不知道这个题目用闭包的话，会写出下面的代码： 123456var list = document.getElementsByTagName('li');for (var i = 0; i &lt; list.length; i++) &#123; list[i].addEventListener('click', function()&#123; alert(i + 1) &#125;, true)&#125; 实际上执行才会发现始终弹出的是6，这时候就应该通过闭包来解决： 12345678var list = document.getElementsByTagName('li');for (var i = 0; i &lt; list.length; i++) &#123; list[i].addEventListener('click', function(i)&#123; return function()&#123; alert(i + 1) &#125; &#125;(i), true)&#125; 要理解闭包，就需要我们从「执行上下文」开始讲起。 执行上下文先讲一个关于 变量提升 的知识点，面试中可能会遇见下面的问题： 题目：说出下面执行的结果（这里笔者直接注释输出了） 12345678910111213console.log(a) // undefinedvar a = 100fn('zhangsan') // 'zhangsan' 20function fn(name) &#123; age = 20 console.log(name, age) var age&#125;console.log(b); // 这里报错// Uncaught ReferenceError: b is not definedb = 100; 在一段 JS 脚本（即一个&lt;script&gt;标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 全局执行上下文 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。 我们来看下上面的面试小题目，为什么a是undefined，而b却报错了，实际 JS 在代码执行之前，要「全文解析」，发现var a，知道有个a的变量，存入了执行上下文，而b没有找到var关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的a是有记录的，只不过值暂时还没有赋值，即为undefined，而b在执行上下文没有找到，自然会报错（没有找到b的引用）。 另外，一个函数在执行之前，也会创建一个 函数执行上下文 环境，跟 全局上下文 差不多，不过 函数执行上下文 中会多出this`` arguments和函数的参数。参数和arguments好理解，这里的this咱们需要专门讲解。 总结一下： 范围：一段&lt;script&gt;、js 文件或者一个函数全局上下文：变量定义，函数声明函数上下文：变量定义，函数声明，this，arguments this先搞明白一个很重要的概念 —— this的值是在执行的时候才能确认，定义的时候不能确认！ 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子 12345678910var a = &#123; name: 'A', fn: function () &#123; console.log(this.name) &#125;&#125;a.fn() // this === aa.fn.call(&#123;name: 'B'&#125;) // this === &#123;name: 'B'&#125;var fn1 = a.fnfn1() // this === window this执行会有不同，主要集中在这几个场景中 作为构造函数执行，构造函数中 作为对象属性执行，上述代码中a.fn() 作为普通函数执行，上述代码中fn1() 用于call apply bind，上述代码中a.fn.call({name: &#39;B&#39;}) 下面再来讲解下什么是作用域和作用域链。 题目：如何理解 JS 的作用域和作用域链 作用域1234if (true) &#123; var name = 'zhangsan'&#125;console.log(name) 从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的name就被暴露出去了，因此，JS 没有块级作用域，只有全局作用域和函数作用域。 1234567var a = 100function fn() &#123; var a = 200 console.log('fn', a)&#125;console.log('global', a)fn() 全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。 123456// 张三写的代码中var data = &#123;a: 100&#125;// 李四写的代码中var data = &#123;x: true&#125; 这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function(){....})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。 附：ES6 中开始加入了块级作用域，使用let定义变量即可，如下： 1234if (true) &#123; let name = 'zhangsan'&#125;console.log(name) // 报错，因为let定义的name是在if这个块级作用域 作用域链首先认识一下什么叫做 自由变量 。如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量如何得到 —— 向父级作用域寻找。 12345678var a = 100function fn() &#123; var b = 200 console.log(a) console.log(b)&#125;fn() 如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。 123456789101112var a = 100function F1() &#123; var b = 200 function F2() &#123; var c = 300 console.log(a) // 自由变量，顺作用域链向父作用域找 console.log(b) // 自由变量，顺作用域链向父作用域找 console.log(c) // 本作用域的变量 &#125; F2()&#125;F1() 闭包讲完这些内容，我们再来看一个例子，通过例子来理解闭包。 12345678910function F1() &#123; var a = 100 return function () &#123; console.log(a) &#125;&#125;var f1 = F1()var a = 200f1() 自由变量将从作用域链中去寻找，但是 依据的是函数定义时的作用域链，而不是函数执行时，以上这个例子就是闭包。闭包主要有两个应用场景： 函数作为返回值，上面的例子就是 函数作为参数传递，看以下例子 123456789101112function F1() &#123; var a = 100 return function () &#123; console.log(a) &#125;&#125;function F2(f1) &#123; var a = 200 console.log(f1())&#125;var f1 = F1()F2(f1) 至此，对应着「作用域和闭包」这部分一开始的点击弹出alert的代码再看闭包，就很好理解了。 闭包的概念各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。 123456789101112131415161718192021function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}“这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意事项 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 参考123456789101112131415var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); 12345678910111213141516var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); (完)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用d3画环形图]]></title>
    <url>%2F%E7%94%A8d3%E7%94%BB%E7%8E%AF%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[目录 目录 定义数据格式 创建虚拟数组，绘制外部弧线 创建svg 创建弧生成器 创建饼布局 转换数据格式 开始绘制 添加line节点 添加文字 绘制外圆 添加图例 添加动画 前言：环形图很好实现，百度的echart图标库就可以实现各种形式的环形，但是还是会有个别环形图的特殊样式，echart实现不了的那就用d3实现吧。 定义数据格式123456789101112131415161718192021222324252627282930313233343536373839404142var dataSet = [&#123; id: 0, name: '国土局', value: 30&#125;, &#123; id: 1, name: '教育局', value: 50&#125;, &#123; id: 2, name: '民宗局', value: 39&#125;, &#123; id: 3, name: '文体局', value: 70&#125;, &#123; id: 4, name: '编办', value: 78&#125;, &#123; id: 5, name: '商务局', value: 33&#125;, &#123; id: 6, name: '财政局', value: 19&#125;, &#123; id: 7, name: '科技局', value: 36&#125;, &#123; id: 8, name: '环保局', value: 60&#125;, &#123; id: 9, name: '其他局', value: 84&#125;]; 创建虚拟数组，绘制外部弧线123456789101112131415161718192021var updateData = function(arr) &#123; var _updateArr = []; var _len = arr.length; for(var i = 0; i &lt; _len; i++) &#123; if(i === _len - 1) &#123; _updateArr.push(&#123; value: ((arr[i].value) / 2 + (arr[0].value) / 2), name: arr[i].name &#125;); &#125; else &#123; _updateArr.push(&#123; value: ((arr[i].value) / 2 + (arr[i + 1].value) / 2), name: arr[i].name &#125;); &#125; &#125;; return _updateArr;&#125;;var outerCircleData = updateData(dataSet);//定义颜色数组var colors = ['#21b6fc', '#7cfdfb', '#32fffe', '#59fee8', '#02d38b', '#d9fd8c', '#ffd553', '#ff396a', '#b860ef', '#015fc8']; 创建svg12345678910111213141516//定义svg宽高var width = 460, height = 238;var svg = d3.select('.comBox') .append('svg') .attr('width', width) .attr('height', height) .append('g') .attr('transform', 'translate(150,120)');//求value总和var grossData = 0;dataSet.map(function(item) &#123; grossData += item.value;&#125;); 创建弧生成器1234var arc = d3.arc() .innerRadius(56) .outerRadius(70) .padAngle(0.01); 创建饼布局12345var pie = d3.pie() .value(function(d) &#123; return d.value; &#125;) .sort(null) 转换数据格式1var pieData = pie(dataSet); 开始绘制1234567891011//添加与data数量相等的g节点var arc_g = svg.selectAll('g') .data(pieData) .enter() .append('g');//添加path节点var arcPath = arc_g .append('path') .attr('d', function(d) &#123; return arc(d) &#125;) 添加line节点123456789101112131415161718arc_g.append('line') .transition() .duration(600) .attr('stroke', '#3e8eff') .attr('stroke-dasharray', ' 1 , 1.5 ') .attr('stroke-width', 2) .attr('x1', function(d) &#123; return arc.centroid(d)[0] * 1.1 &#125;) .attr('y1', function(d) &#123; return arc.centroid(d)[1] * 1.1 &#125;) .attr('x2', function(d) &#123; return arc.centroid(d)[0] * 1.3 &#125;) .attr('y2', function(d) &#123; return arc.centroid(d)[1] * 1.3 &#125;); 添加文字1234567891011121314arc_g.append('text') .transition() .duration(600) .attr('transform', function(d) &#123; var x = arc.centroid(d)[0] * 1.5; var y = arc.centroid(d)[1] * 1.48; return "translate(" + (x + 3) + "," + (y + 5) + ")"; &#125;) .attr("font-size", "14px") .attr("font-family", "微软雅黑") .style("text-anchor", "middle") .attr("fill", '#02f4ff') .text(function(d) &#123; return Math.ceil(d.value / grossData * 100) + '%'; 绘制外圆1234567891011121314151617var arc = d3.arc() .innerRadius(76) .outerRadius(77) .padAngle(0.08); var arcLineData = pie(outerCircleData); var arcLine_g = svg.append('g') .attr('transform', 'rotate(12)'); arcLine_g.selectAll('path') .data(arcLineData) .enter() .append('path') .attr('d', function(d) &#123; console.log(d) return arc(d) &#125;) .attr('fill', '#3e8eff'); 添加图例123456789101112131415161718192021222324252627282930313233343536var rects = svg.append('g') .attr('transform', 'translate(170,-80)');var rect_g = rects.selectAll('g') .data(dataSet) .enter() .append('g');rect_g.append('rect') .transition() .duration(600) .delay(function(d,i)&#123; console.log(d,i) return i*50 &#125;) .attr('width', 20) .attr('height', 8) .attr('y', function(d, i) &#123; return 18 * i; &#125;) .attr('fill', function(d, i) &#123; return colors[i] &#125;);rect_g.append('text') .attr("font-size", "14px") .attr("font-family", "微软雅黑") .style("text-anchor", "middle") .attr("fill", '#30b4ff') .attr('dy', 10) .attr('y', function(d, i) &#123; return 18 * i; &#125;) .attr('x', 60) .text(function(d) &#123; return d.name &#125;) 添加动画123456789arcPath .transition() .duration(1500) .delay(function(d, i) &#123; return i * 50; &#125;) .attr('fill', function(d) &#123; return colors[d.data.id] &#125;); 最终效果图： 本文d3相关属性和方法讲解：d3.arc() - 创建一个新弧生成器arc.innerRadius() - 设置内半径arc.outerRadius() - 设置外半径arc.padAngle() - 设置相邻弧之间的夹角（取值范围0~0.1）arc.centroid() - 弧中心arc.centroid(d)[0] - x轴坐标arc.centroid(d)[1 ] - y轴坐标d3.transition() - 添加动画transition.duration - 指定每个元素的持续时间（以毫米为单位）。transition.delay - 指定每个元素的延迟时间（以毫米为单位）。]]></content>
      <categories>
        <category>d3</category>
      </categories>
      <tags>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用d3画出气泡图]]></title>
    <url>%2F%E7%94%A8d3%E7%94%BB%E5%87%BA%E6%B0%94%E6%B3%A1%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[目录 目录 定义数据格式 创建svg 求圆最大最小半径比例尺 定义一个线性渐变 画圆 画虚线圆 添加文字 最终效果图 本文d3 相关属性和方法： 工作中遇到需要实现一个类似气泡图的效果，我试着用d3画了一下。 定义数据格式123456789101112131415161718192021222324252627//定义宽高let width = 360, height = 167;//定义数据结构let datas = [&#123; "name": "资源造假", "value": 3938&#125;, &#123; "name": "信用卡逾期", "value": 3812&#125;, &#123; "name": "住房贷款逾期", "value": 671&#125;, &#123; "name": "交通768违法", "value": 6714&#125;, &#123; "name": "涉及进入企业", "value": 1714&#125;, &#123; "name": "超额负债", "value": 5900&#125;];//定义颜色let linearColor = '#022d3f'; let colors = ['#e91653', '#01d182', '#d6e132', '#017d9e', '#0146a6', '#7a15dc']; 创建svg123456789101112131415161718//创建svglet svgDom = d3.select('body') .append("svg") .attr('width', width) .attr('height', height) .append('g') .attr('transform', 'translate(0,30)');//添加跟数据长度对等的g节点let nodes = svgDom.selectAll('.node') .data(datas) .enter() .append('g') .attr('class', 'node') .attr('transform', function(d, i) &#123; let num = i % 2; return 'translate(' + (56 * i + 30) + ',' + (52 * num + 30) + ')' &#125;); 求圆最大最小半径比例尺123456789101112//最小值let min = d3.min(datas, function(p) &#123; return p.value;&#125;);//最大值let max = d3.max(datas, function(p) &#123; return p.value;&#125;);let scaleVal = d3.scaleLinear() .domain([min, max]) .range([15, 33]); 定义一个线性渐变1let defs = svgDom.append("defs"); 画圆1234567891011121314151617181920212223242526272829nodes.append('circle').attr('r', function(d, i) &#123; return scaleVal(d.value);&#125;).attr('cx', 0).attr('cy', 0).attr('fill', function(d,i)&#123; //添加渐变效果 let linearGradient = defs.append("linearGradient") .attr("id", "linearColor"+i) .attr("x1", "0%") .attr("y1", "0%") .attr("x2", "0%") .attr("y2", "100%"); let stop1 = linearGradient.append("stop") .attr("offset", "0%") .style("stop-color", linearColor.toString()); let stop2 = linearGradient.append("stop") .attr("offset", "100%") .style("stop-color", colors[i].toString()); return "url(#" + linearGradient.attr("id") + ")"; &#125;).attr('stroke',function(d,i)&#123; return colors[i];&#125;).attr('opacity',0.8); 画虚线圆1234567891011nodes.append('circle') .attr('r', function(d, i) &#123; return scaleVal(d.value) + 4; &#125;) .attr('cx', 0) .attr('cy', 0) .attr('fill', 'transparent') .attr('stroke-dasharray', "2,2") .attr('stroke', function(d, i) &#123; return colors[i]; &#125;) 添加文字12345678910111213nodes.append('text') .attr('dy', 5) .text(function(d) &#123; return d.name; &#125;) .attr('fill', '#fff') .attr('font-size', 12) .attr('text-anchor', 'middle');function randomData() &#123; console.log(1) return d3.range(6).map( function() &#123; return Math.random()*20; &#125; )&#125;; 最终效果图 本文d3 相关属性和方法：stroke-dasharray：属性用来设置描边的点划线的图案范式。就是设置实线和虚线的宽度d3.range:生成一组数值d3.scaleLinear:线性比例尺 =&gt;d3.scaleLinear()domain:定义域 =&gt;domain([min,max])range:值域 =&gt;range([10,50])]]></content>
      <categories>
        <category>d3</category>
      </categories>
      <tags>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react native 图标解决方案]]></title>
    <url>%2Freact-native-%E5%9B%BE%E6%A0%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[目录 目录 业务背景 决定实施方案 （svg） RN部分安装 ios部分添加依赖 使用方法 属性 脚本处理 封装Svg Component 使用 DEMO 业务背景接手前同事的一个RN项目， 项目中的图标采用的方案是iconfont。 iconfont的优点: 文件小 使用便利， 不用担心屏幕屏幕尺寸 都不错，但是缺点对我来说确实致命的： 不能热更新 于是上网查资料寻求更好的解决方案 ，找到了几种解决方案。 列出下优缺点对比下 技术方案 优点 缺点 图片(打包) 使用方便，直接用require和Image标签就可以使用 bundle体积增大，特别是热更新对流量，影响太大。需要根据屏幕不同准备多种尺寸。 图片(URI) 同上，更换方便，远程管理 基本同上， 缓存管理比较麻烦，需要另外的库。 IconFont 随app打包，文件小，使用便利，不用担心屏幕屏幕尺寸 不能热更新，需要引入额外的库 svg(打包) 文件极小，可随bundle热更新，可缩放图形，不用担心屏幕尺寸问题 需要引入额外的库 svg(URI) 基本同图片，不用担心屏幕尺寸 缓存 决定实施方案 （svg）鉴于使用图片为了防止模糊，要准备多倍图，首先就被pass掉了。而字体图标做为我常用的手段，特别是公司的字体是通过icomoo这种网站统一管理的，本来是很倾向于使用的，奈何.ttf文件必须随项目打包到app里面，不能热更新。至少在没有放弃codepush的情况下，只能放弃了。接下来就只有使用svg了 。 svg的体积极小，几十个图标文件加起来不到3k，随bundle打包是最好的选择，正好现在的字体图标管理网站也能生成svg文件，很方便和设计师合作。设计师只用将需要使用的svg图标上传到icomoo上命名好，然后打包下载就能使用。 使用react-native-svg就能对svg的标签解析成图片，而使用react-native-svg-uri则能把svg文件的xml解析成响应的component。这样就能把svg文件转化成图形。但是后来发现这在安卓中行不通，因为安卓的RN项目在release打包后（非debug模式），只能允许require png和xml格式的文件。不过这并不是什么大问题，本来对icomoo生成svg文件中，我们仅仅需要path标签，其余的都是浪费空间的，而且频繁require静态文件也会减慢速度。我们可以用脚本来将svg文件批量生成js使用的字符串，然后通过react-native-svg-uri来解析xml。这个库作者也考虑到android的问题预留了接受字符串的api。 RN部分安装1npm install react-native-svg --save ios部分添加依赖 使用xcode中打开React-native中的iOS项目，选中‘Libraries’目录 ——&gt; 右键选择‘Add Files to 项目名称’ ——&gt; ‘node_modules/react-native/Libraries/react-native-svg/RNSVG.xcodeproj’ 添加 选中项目根目录 ——&gt; 点击’Build Phases‘ ——&gt; 点击‘Link Binary With Libraries’ ——&gt; 点击左下方‘+’ ——&gt; 选中‘libRNSVG.a’添加。 使用方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Svg,&#123; Circle, Ellipse, G, LinearGradient, RadialGradient, Line, Path, Polygon, Polyline, Rect, Symbol, Text, Use, Defs, Stop&#125; from 'react-native-svg';class SvgExample extends Component &#123; render() &#123; return ( &lt;Svg height="100" width="100" &gt; &lt;Circle cx="50" cy="50" r="45" stroke="blue" strokeWidth="2.5" fill="green" /&gt; &lt;Rect x="15" y="15" width="70" height="70" stroke="red" strokeWidth="2" fill="yellow" /&gt; &lt;/Svg&gt; ); &#125;&#125; 属性 属性名称 默认值 描述 fill ‘#000’ 内部填充规则(填充颜色，填充渐变图形) fillOpacity 1 填充的透明度 stroke ‘none’ 描边颜色 strokeWidth 1 描边的宽度 strokeOpacity 1 描边的透明度 strokeLinecap ‘square’ 描边线段端点显示方式 strokeLinejoin ‘miter’ 描边线段连接处的显示方式 strokeDasharray [] 描边线段断点显示规则 x 0 当前图形x轴偏移量 y 0 当前图形y轴偏移量 rotate 0 当前图形旋转值 scale 1 当前图形的缩放值 origin 0, 0 变形原点(x,y,rotate,scale的变形原点坐标) originX 0 变形原点x轴坐标 originY 0 变形原点y轴坐标 脚本处理每次进app请求多个svg很浪费资源，并且安卓本身就不支持svg静态文件的require，所以我们需要用简单的脚本处理一下，把多个svg的字符合并到一个js对象中，代码如下，运行下面的脚本 node getSvg。这里我时用node写的，当然你也可以用自己习惯的脚本语言来处理。 123456789101112131415161718192021222324252627282930313233343536373839// getSvg.jsvar fs = require('fs');var path = require('path');const svgDir = path.resolve(__dirname, './svgs');// 读取单个文件function readfile(filename) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path.join(svgDir, filename), 'utf8', function(err, data) &#123; console.log(data.replace(/&lt;\?xml.*?\?&gt;|&lt;\!--.*?--&gt;|&lt;!DOCTYPE.*?&gt;/g, '')); if (err) reject(err); resolve(&#123; [filename.slice(0, filename.lastIndexOf('.'))]: data, &#125;); &#125;); &#125;);&#125;// 读取SVG文件夹下所有svgfunction readSvgs() &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readdir(svgDir, function(err, files) &#123; if (err) reject(err); Promise.all(files.map(filename =&gt; readfile(filename))) .then(data =&gt; resolve(data)) .catch(err =&gt; reject(err)); &#125;); &#125;);&#125;// 生成js文件readSvgs().then(data =&gt; &#123; let svgFile = 'export default ' + JSON.stringify(Object.assign.apply(this, data)); fs.writeFile(path.resolve(__dirname, './svgs.js'), svgFile, function(err) &#123; if(err) throw new Error(err); &#125;)&#125;).catch(err =&gt; &#123; throw new Error(err); &#125;); 这样生成了一个svgs.js文件。其结构是 123456// svgs.jsexport default &#123; 'svgName1': 'xmlData1...', 'svgName2': 'xmlData2...', ...&#125; 封装Svg Component123456789101112131415161718192021222324252627282930313233// Svg.jsimport React, &#123; Component &#125; from 'react';import &#123; ViewStyle,&#125; from 'react-native'import SvgUri from '../../lib/react-native-svg-uri';import svgs from '../../assets/svgs';export default class Svg extends Component&lt;SvgProperties, void&gt;&#123; render() &#123; const &#123; iocn, color, size, style, &#125; = this.props; let svgXmlData = svgs[this.props.icon]; if (!svgXmlData) &#123; let err_msg = `没有"$&#123;this.props.icon&#125;"这个icon，请下载最新的icomoo并 npm run build-js`; throw new Error(err_msg); &#125; return ( &lt;SvgUri width=&#123;size&#125; height=&#123;size&#125; svgXmlData=&#123;svgXmlData&#125; fill=&#123;color&#125; style=&#123;style&#125; /&gt; ) &#125;&#125; 使用123render() &#123; return &lt;Svg icon="ac_unit" size="40" fill="#ccc"/&gt;&#125; DEMOleeguooooo/react-native-svg-demo 注: react-native-art-svg 已改名 react-native-svg]]></content>
      <categories>
        <category>react native</category>
      </categories>
      <tags>
        <tag>react-native-svg</tag>
        <tag>react-native-art-svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令推荐 thefuck]]></title>
    <url>%2F%E5%91%BD%E4%BB%A4%E6%8E%A8%E8%8D%90-thefuck%2F</url>
    <content type="text"><![CDATA[目录 目录 安装 配置 效果 使用须知 自定义规则 今天要讲的主角：thefuck , 一个修复错误的命令工具。 开发者都或多或少接触过 linux 接触过命令行, 当然肯定也都被命令行狠狠地&quot;fuck&quot;过. 我很多时候都是微不足道的原因导致了命令行出错, 例如将 python 输入成 ptyhon, 例如将 ls -alh 输入成 ls a-lh 而导致出错，这个时候我会想说 : “fuck” 安装Ubuntu123sudo apt updatesudo apt install python3-dev python3-pipsudo pip3 install thefuck Mac1brew install thefuck 配置Mac 将eval $(thefuck --alias)复制到 ~/.zshrc 中，执行source ~/.zshrc 效果1234567891011121314151617181920212223242526272829➜ /Users/lee.guo/qunar.com/mobile/qchat_pb git:(newRead) &gt;git brach -agit: 'brach' is not a git command. See 'git --help'.The most similar command is branch➜ /Users/lee.guo/qunar.com/mobile/qchat_pb git:(newRead) &gt;fuckgit branch -a [enter/↑/↓/ctrl+c] NewUI master* newRead remotes/origin/2018-3-26-NewRn remotes/origin/HEAD -&gt; origin/master remotes/origin/NewUI remotes/origin/bugfix_qtalk_v8.35 remotes/origin/bugfix_qtalk_v8.35_1 remotes/origin/collection remotes/origin/first_TLS remotes/origin/google-auth remotes/origin/historyForJson remotes/origin/huawei_push remotes/origin/imSdk remotes/origin/json remotes/origin/master remotes/origin/newRead remotes/origin/newRn remotes/origin/qchat_review remotes/origin/qchat_review_8.27 remotes/origin/qtalk-camera remotes/origin/tls 使用须知虽然 · 带来了很多便利，不过仍然建议注意这件事情： thefuck 会给出的修正后的命令，但是默认情况下你看到它们的时候，命令都已经默认执行了。大部分情况下，thefuck 可能给出的是正确的修正，但是小部分情况下，给出的修正并不是你想要的。所以建议将 ~/.thefuck/settings.py 中的设置改为 require_confirmation = True，这样可以自己决定是否执行修正后的命令。 自定义规则当然，你也可以自定义修正规则：一个自定义规则的案例：1234567891011121314151617def match(command, settings): return ('permission denied' in command.stderr.lower() or 'EACCES' in command.stderr)# 获取 stderr 中的字符串和程序返回值（errno），# 修正规则（命令前添加 sudo）def get_new_command(command, settings): return 'sudo &#123;&#125;'.format(command.script)# 以下为可选项# 默认是否开启enabled_by_default = True# 附加命令def side_effect(command, settings): subprocess.call('chmod 777 .', shell=True)# 优先级，数字越大优先级越低。priority = 1000]]></content>
      <categories>
        <category>命令</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五线谱基础学习]]></title>
    <url>%2F%E4%BA%94%E7%BA%BF%E8%B0%B1%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[目录 目录 认识五线谱 学习视频 最后 认识五线谱一、以下图示五条线,就是五线谱.分一、二、三、四、五条线。二、五条线中间的空白处为间，共有四间。三、下图有高音谱号和低音谱号的介绍 四、五线谱、简谱音阶对照示意图 学习视频观看下面十个视频，大概三个小时就可以自学完成 链接地址，下方有视频doyudo乐理系统学习路径doyudo五线谱教学视频 五线谱知识速学3-第一天五线谱知识速学4-第二天五线谱知识速学5-第三天五线谱知识速学6-第四天五线谱知识速学7-第五天五线谱知识速学8-第六天五线谱知识速学9-第七天五线谱知识速学10-第八天五线谱知识速学11-第九天五线谱知识速学12-第十天 最后这些知识对于初学五线谱的人来说，已经足够足够了]]></content>
      <categories>
        <category>钢琴</category>
      </categories>
      <tags>
        <tag>五线谱</tag>
        <tag>钢琴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个看不见的字符]]></title>
    <url>%2F%E4%B8%80%E4%B8%AA%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[目录 前言 查找问题 如何产生 测试主流的APP对特殊字符的支持 前言今天在写一篇博客的时候出现了一个bug，问题的现象有如下几个 搜索功能无限的loading… search.xml报错 RRS报错 atom.xml报错 查找问题 报错信息 Input is not proper UTF-8, indicate encoding ! 网上Google了一下， 说是博客的内容中出现的特殊字符。 于是开始疯狂的二分法查找这个特殊字符。 然后就发现了一个很神奇的字符，这个字符根本看不见。 我大概可以用搜索功能搜出来， 它长这样： 如何产生直到写博客的时候我还没办法复现。 写着写着突然出现了这个神奇字符。 列一下当前的复现条件： Mac电脑 搜狗中文输入法 atom编辑器 复现过程： 使用输入法输入汉语拼音 开始删除输入的内容 全部删除完成之后就会出现了 如果需要复制字符的地址请点击链接跳转 测试主流的APP对特殊字符的支持 ❌ 微信姓名 ✅ 微信备注 ✅ 微信朋友圈 [ ] 王者荣耀名称待测试 附截图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo如何添加markdown目录]]></title>
    <url>%2Fhexo%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0markdown%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[方案一 新增构建脚本 设置启动 完成 方案二(目前在用,需要atom) 安装 配置 完成 ##方案一 新增构建脚本在根目录下创建build.sh 12345678910111213#!/bin/shmodulePath="node_modules"if [ ! -d "$modulePath" ]; then echo "Not found node_modules! &amp;&amp; install" npm install --registry=http://registry.npm.corp.qunar.com/fidoctoc ./source/_postshexo cleanhexo ghexo s 设置启动在package.json中添加以下内容 1234567"scripts": &#123; "postinstall": "node scripts/postinstall.js --verbose", "build": "sh build.sh", "dev": "hexo serve", "start": "sh build.sh", "up": "sh scp.sh"&#125; 完成每次编辑完成后执行 npm start 就自动生成了带目录的文章了 方案二(目前在用,需要atom)安装在atom中安装markdown-toc 配置打开 scaffolds post.md 文件 修改123456789101112131415title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: 郭立leecategory:tags:photos:copyright: true---&lt;!-- @import "[TOC]" &#123;cmd="toc" depthFrom=2 depthTo=6 orderedList=false&#125; --&gt;&lt;!-- code_chunk_output --&gt;##目录* [目录](#目录)&lt;!-- /code_chunk_output --&gt; 完成每次编辑完成报错即可]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>markdown目录</tag>
        <tag>生成目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小李的面试总结0002]]></title>
    <url>%2F%E5%B0%8F%E6%9D%8E%E7%9A%84%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%930002%2F</url>
    <content type="text"><![CDATA[目录 js事件代理是什么 事件代理是什么 为什么要用事件委托(事件代理)： 事件委托(事件代理)的原理： 事件委托(事件代理)怎么实现： 总结： 二叉树执行顺序 元素水平垂直居中 用css画三角形 Jsonp a页面跳转b页面，怎么知道是a页面跳转过去的 Cookie和另外两个的区别 模块开发用什么 两个数组，不改变自身，进行排序 Const和let区别 Vue生命周期 有哪些钩子函数 Css盒子模型 一个数组，找出第二大的 遇到数据特别多的情况，页面卡顿如何优化 页面加载过程 301.302代表什么 一个元素在body中，算出它的位置 用过哪些技术栈 react父组件和子组件如何通信 js里面改变元素宽度，会发生什么操作 React 什么是虚拟dom，虚拟dom有什么好处 前言 一、什么是虚拟DOM？ 二、虚拟DOM VS 直接操作原生DOM？ 三、对React虚拟DOM的误解？ 四、react虚拟dom的好处 五、虚拟dom的缺点 六、diff算法 从打开一个页面到全部显示，中间经过了哪些操作 用没用过css的box-sizing 语法 实例 js事件代理是什么 这是一道前端面试的经典题 有找工作的小伙伴们可以看看 事件代理是什么事件代理又名事件委托，《JavaScript高级程序设计》上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理： 有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。 这里其实还有2层意思的： 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的； 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。 为什么要用事件委托(事件代理)：一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？ 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能； 每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。 事件委托(事件代理)的原理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 事件委托(事件代理)怎么实现：终于到了本文的核心部分了，哈哈，在介绍事件委托的方法之前，我们先来看一段一般方法的例子： 子节点实现相同的功能： 123456&lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 实现功能是点击li，弹出123： 123456789window.onload = function()&#123; var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125;&#125; 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li； 那么我们用事件委托的方式做又会怎么样呢？ 123456window.onload = function()&#123; var oUl = document.getElementById("ul1"); oUl.onclick = function()&#123; alert(123); &#125;&#125; 这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招： Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）： 1234567891011window.onload = function()&#123; var oUl = document.getElementById("ul1"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125; 这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！ 上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？ 123456&lt;div id="box"&gt; &lt;input type="button" id="add" value="添加" /&gt; &lt;input type="button" id="remove" value="删除" /&gt; &lt;input type="button" id="move" value="移动" /&gt; &lt;input type="button" id="select" value="选择" /&gt; &lt;/div&gt; 1234567891011121314151617181920window.onload = function()&#123; var Add = document.getElementById("add"); var Remove = document.getElementById("remove"); var Move = document.getElementById("move"); var Select = document.getElementById("select"); Add.onclick = function()&#123; alert('添加'); &#125;; Remove.onclick = function()&#123; alert('删除'); &#125;; Move.onclick = function()&#123; alert('移动'); &#125;; Select.onclick = function()&#123; alert('选择'); &#125; &#125; 上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？ 123456789101112131415161718192021222324window.onload = function()&#123; var oBox = document.getElementById("box"); oBox.onclick = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == 'input')&#123; switch(target.id)&#123; case 'add' : alert('添加'); break; case 'remove' : alert('删除'); break; case 'move' : alert('移动'); break; case 'select' : alert('选择'); break; &#125; &#125; &#125; &#125; 用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的 现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？ 看一下正常的添加节点的方法： 1234567&lt;input type="button" name="" id="btn" value="添加" /&gt; &lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; 现在是移入li，li变红，移出li，li变白，这么一个效果，然后点击按钮，可以向ul中添加一个li子节点 1234567891011121314151617181920212223window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125;; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;; &#125; 这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下： 123456789101112131415161718192021222324252627window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; function mHover () &#123; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125;; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; &#125; mHover (); //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); mHover (); &#125;; &#125; 虽然功能实现了，看着还挺好，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的，那么有事件委托的方式，能做到优化吗？ 1234567891011121314151617181920212223242526272829303132window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "red"; &#125; &#125;; oUl.onmouseout = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "#fff"; &#125; &#125;; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;; &#125; 看，上面是用事件委托的方式，新添加的子元素是带有事件效果的，我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行，这样可以大大的减少dom操作，这才是事件委托的精髓所在。 现在给一个场景 ul &gt; li &gt; div &gt; p，div占满li，p占满div，还是给ul绑定时间，需要判断点击的是不是li（假设li里面的结构是不固定的），那么e.target就可能是p，也有可能是div，这种情况你会怎么处理呢？ 那我们现在就再现一下这个场景 1234567891011121314 &lt;ul id="test"&gt; &lt;li&gt; &lt;p&gt;11111111111&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; 22222222 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;3333333333&lt;/span&gt; &lt;/li&gt; &lt;li&gt;4444444&lt;/li&gt;&lt;/ul&gt; 如上列表，有4个li，里面的内容各不相同，点击li，event对象肯定是当前点击的对象，怎么指定到li上，下面我直接给解决方案： 1234567891011 var oUl = document.getElementById('test');oUl.addEventListener('click',function(ev)&#123; var target = ev.target; while(target !== oUl )&#123; if(target.tagName.toLowerCase() == 'li')&#123; console.log('li click~'); break; &#125; target = target.parentNode; &#125;&#125;) 核心代码是while循环部分，实际上就是一个递归调用，你也可以写成一个函数，用递归的方法来调用，同时用到冒泡的原理，从里往外冒泡，知道currentTarget为止，当当前的target是li的时候，就可以执行对应的事件了，然后终止循环，恩，没毛病！ 这里看不到效果，大家可以复制过去运行一下！ 总结：那什么样的事件可以用事件委托，什么样的事件不可以用呢？ 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。 值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。 不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。 好了，今天就到这里，下次我想介绍一下事件绑定，欢迎大家关注和阅读，以上纯属个人见解，如有不对的地方，万望指正，不胜感谢！ 以上内容参考自： js中的事件委托或是事件代理详解 二叉树执行顺序元素水平垂直居中用css画三角形1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style&gt; div&#123; width:0; height:0; border: 200px solid; /*border-color:#02F4FF #FF0000 #FF1F6E #FFFFFF;*/ border-top:200px solid red; &#125; &lt;/style&gt; &lt;body style="background:#000"&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Jsonpa页面跳转b页面，怎么知道是a页面跳转过去的Cookie和另外两个的区别模块开发用什么两个数组，不改变自身，进行排序Const和let区别 这是一道送命题，这里不写答案了。 请参见ES6语法。 Vue生命周期有哪些钩子函数Css盒子模型一个数组，找出第二大的123var aa = [1,5,3,6,3];aa[aa.indexOf(Math.max(...aa))]=null;Math.max(...aa) 思路是，找出数组中第一大的值设置为null，再求数组中最大值； 遇到数据特别多的情况，页面卡顿如何优化页面加载过程301.302代表什么 301是永久重定向，而302是临时重定向。 当然，他们之间也是有共同点的，就是用户都可以看到url替换为了一个新的，然后发出请求。 差异 对于用户301，302对用户来说没有区别，他们看到效果只是一个跳转，浏览器中旧的URL变成了新的URL。页面跳到了这个新的url指向的地方。 对于引擎及站长302转向可能会有URL规范化及网址劫持的问题。可能被搜索引擎判为可疑转向，甚至认为是作弊。 详细信息见： 参考链接 你在项目中担任什么角色 一个元素在body中，算出它的位置用过哪些技术栈react父组件和子组件如何通信js里面改变元素宽度，会发生什么操作React 什么是虚拟dom，虚拟dom有什么好处 虚拟dom是在dom的基础上建立一个抽象层，对数据和状态所作的任何变动，都会高效同步到虚拟dom，最后会批量同步到dom中；在react中，render执行得到的dom并不是真正的dom，而是一个javascript对象，称为虚拟dom 虚拟dom的优点是最终表现在dom上的修改只是变更的部分，可以保证页面更高效的渲染 前言在Web开发中，需要将数据的变化实时反映到UI上，这时就需要对DOM进行操作，但是复杂或频繁的DOM操作通常是性能瓶颈产生的原因，为此，React引入了虚拟DOM（Virtual DOM）的机制。 一、什么是虚拟DOM？在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。 虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。在实际开发中基本无需关心虚拟DOM是如何运作的，但是理解其运行机制不仅有助于更好的理解React组件的生命周期，而且对于进一步优化 React程序也会有很大帮助。 二、虚拟DOM VS 直接操作原生DOM？如果没有 Virtual DOM，简单来说就是直接重置 innerHTML。这样操作，在一个大型列表所有数据都变了的情况下，还算是合理，但是，当只有一行数据发生变化时，它也需要重置整个 innerHTML，这时候显然就造成了大量浪费。 比较innerHTML 和Virtual DOM 的重绘过程如下： innerHTML: render html string + 重新创建所有 DOM 元素 Virtual DOM: render Virtual DOM + diff + 必要的 DOM 更新 和 DOM 操作比起来，js 计算是非常便宜的。Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是，它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。当然，曾有人做过验证说React的性能不如直接操作真实DOM，代码如下： 1234567891011121314function Raw() &#123; var data = _buildData(), html = ""; ... for(var i=0; i&lt;data.length; i++) &#123; var render = template; render = render.replace("&#123;&#123;className&#125;&#125;", ""); render = render.replace("&#123;&#123;label&#125;&#125;", data[i].label); html += render; &#125; ... container.innerHTML = html; ...&#125; 该测试用例中虽然构造了一个包含1000个Tag的String，并把它添加到DOM树中，但是只做了一次DOM操作。然而，在实际开发过程中，这1000个元素更新可能分布在20个逻辑块中，每个逻辑块中包含50个元素，当页面需要更新时，都会引起DOM树的更新，上述代码就近似变成了如下格式： 123456789101112131415function Raw() &#123; var data = _buildData(), html = ""; ... for(var i=0; i&lt;data.length; i++) &#123; var render = template; render = render.replace("&#123;&#123;className&#125;&#125;", ""); render = render.replace("&#123;&#123;label&#125;&#125;", data[i].label); html += render; if(!(i % 50)) &#123; container.innerHTML = html; &#125; &#125; ...&#125; 这样来看，React的性能就远胜于原生DOM操作了。 而且，DOM 完全不属于Javascript (也不在Javascript 引擎中存在).。Javascript 其实是一个非常独立的引擎，DOM其实是浏览器引出的一组让Javascript操作HTML文档的API而已。在即时编译的时代，调用DOM的开销是很大的。而Virtual DOM的执行完全都在Javascript 引擎中，完全不会有这个开销。 React.js 相对于直接操作原生DOM有很大的性能优势， 很大程度上都要归功于virtual DOM的batching 和diff。batching把所有的DOM操作搜集起来，一次性提交给真实的DOM。diff算法时间复杂度也从标准的的Diff算法的O(n^3)降到了O(n)。这里留到下一次博客单独讲。 三、对React虚拟DOM的误解？React 从来没有说过 “React 比原生操作 DOM 快”。React给我们的保证是，在不需要手动优化的情况下，它依然可以给我们提供过得去的性能。 React掩盖了底层的 DOM 操作，可以用更声明式的方式来描述我们目的，从而让代码更容易维护。下面还是借鉴了知乎上的回答：没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。 四、react虚拟dom的好处最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染。 虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时“刷新”整个页面，因为虚拟DOM可以确保只对界面上真正变化的部分进行实际的DOM操作。 五、虚拟dom的缺点首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。 转载自AlloyTeam：http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/ 推荐参考资料：为什么虚拟DOM更胜一筹 六、diff算法其次，想分享下diff算法。前两天看司徒正美推销他的Avalon，也分析了下React，说了一句话，现在前端框架比的是算法。diff算法说白了就是比较两个文件不同的算法。一般diff算法的复杂度是O(n3)。Facebook工程师根据前端页面特点做了两个假设（如果你好奇是什么假设这么神奇，可以来问我），把比较前后两个状态虚拟DOM的diff算法的复杂度降到了O(n)。这个diff算法分为三部分，我用三句话总结： 虚拟DOM树同一位置不同类型（标签不同）的节点：删除前一状态节点，插入后一状态节点，哪怕节点有子节点也这样做； 虚拟DOM树同一位置相同类型但个别属性不同的节点，对前一状态节点进行属性重设； 列表节点（就是我们用循环创建的类似Array的节点），如果没有unique key（没有控制台会报警告的）就按照前面两种方式解决，如果有unique key就找到key相应的位置插入节点。 真的很简单，印证了一句话，简单的算法往往效率最高，好像我做推荐算法，单个算法不混合的话，依然是协同过滤效果最好。 从打开一个页面到全部显示，中间经过了哪些操作用没用过css的box-sizing 假如您需要并排放置两个带边框的框，可通过将 box-sizing 设置为 “border-box”。这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。 语法1box-sizing: content-box|border-box|inherit; 值 描述 content-box(默认值) 这是由 CSS2.1 规定的宽度高度行为。 宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 border-box 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 inherit 规定应从父元素继承 box-sizing 属性的值。 浏览器支持 Internet Explorer、Opera 以及 Chrome 支持 box-sizing 属性。Firefox 支持替代的 -moz-box-sizing 属性。 参考文章：学会使用box-sizing布局 实例12345678div&#123;box-sizing:border-box;-moz-box-sizing:border-box; /* Firefox */-webkit-box-sizing:border-box; /* Safari */width:50%;float:left;&#125; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div.container&#123; width:30em; border:1em solid; &#125; div.box&#123; box-sizing:border-box; -moz-box-sizing:border-box; /* Firefox */ -webkit-box-sizing:border-box; /* Safari */ width:50%; border:1em solid red; float:left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="box"&gt;这个 div 占据左半部分。&lt;/div&gt; &lt;div class="box"&gt;这个 div 占据右半部分。&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>前端</tag>
        <tag>事件代理</tag>
        <tag>二叉树</tag>
        <tag>Jsonp</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 16.3 新特性]]></title>
    <url>%2FReact-16-3-%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[目录 新的Context API 新的声明周期方法 static getDerivedStateFromProps 值得注意的事 Static Mode AsyncMode 新版React Developer Tools React 16.3-alpha已经发布。这次发布都有哪些新特性呢，我们来一起看看。 新的Context API Context API总是很让人迷惑。这个API是官方的，但是官方又不希望开发者们使用这个API，说是这个API会在以后发生改变。现在就是那个改变的时刻。新的API已经被merge了。而且它看起来更加的“用户友好”了。尤其是你不得不使用redux、mobx的时候，可以选择新的Context API实现更加简单的状态管理。 新的API用起来非常的简单：React.createContext()，这样就创建了两个组件： 123456import &#123;createContext&#125; from 'react';const ThemeContext = createContext(&#123; background: 'yellow', color: 'white'&#125;); 调用createContext方法会返回两个对象，一个是Provider，一个是Consumer。 那个Provider是一个特殊的组件。它可以用来给子树里的组件提供数据。一个例子： 123456789class Application extends React.Component &#123; render() &#123; &lt;ThemeContext.Provider value=&#123;&#123;background: 'black', color: 'white'&#125;&#125;&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;Footer /&gt; &lt;/ThemeContext.Provider&gt; &#125;&#125; 上例展示了如何传递“theme” context的。当然这些值可以是动态的（比如，基于this.state）。 下一步就是使用Consumer。 1234567891011const Header = () =&gt; &#123; &lt;ThemeContext.Consumer&gt; &#123;(context) =&gt; &#123; return ( &lt;div style=&#123;&#123;background: context.background, color: context.color&#125;&#125;&gt; Welcome! &lt;/div&gt; ); &#125;&#125; &lt;/ThemeContext.Consumer&gt;&#125; 如果在render Consumer的时候没有嵌套在一个Provider里面。那么就会使用createContext方法调用的时候设置的默认值。 注意: Consumer必须可以访问到同一个Context组件。如果你要创建一个新的context，用的是同样的入参，那么这个新建的context的数据是不可访问的。因此，可以把Context当做一个组件，它可以创建一次，然后可以export，可以import。 这个新的语法用了function as child模式（有时也叫做render prop模式）。如果不是很熟悉这个模式，那么推荐你看一下这些文章。 新的API不再要求你声明contextProps了。 新的声明周期方法 参考这个RFC。新的声明周期方法会被引入，而旧的会被废弃。 这一改变主要是为了强制推行最佳实践。你可以看看这篇文章来了解一下为什么这些生命周期方法会变得很诡异。这些最佳模式在React 16的异步绘制模式(Async Mode)下显得非常重要。 要被废弃的方法： componentWillMount–使用componentDidMount代替 componentWillUpdate–使用componentDidUpdate代替 componentWillReceiveProps–使用一个新的方法：static getDerivedStateFromProps来代替。 不过这些并不会立刻发生，他们可以用到React 16.4。在React 17里将被彻底移除。如果你开启了StrictMode或者AsyncMode，可以通过这样的方式来使用，但是会收到警告： UNSAFE_componentWillMount UNSAFE_componentWillReceiveProps UNSAFE_componentWillUpdate static getDerivedStateFromProps当componentWillReceiveProps我们需要其他的方式根据props的变动更新state。社区决定引入一个新的static方法来处理这个问题。 什么是静态方法？一个静态方法就是存在于类内，而不是类的实例内的方法。静态方法访问不到this，并且在声明的时候有static关键字在前面修饰。 但是，问题来了。既然这个方法没有办法访问this，那么如何调用this.setState呢？答案就是，不调用。这个方法直接返回需要更新的state的数据，或者返回null，如果没有什么需要更新的话。 12345678910static getDerivedStateFromProps(nextProps, prevState) &#123; if(nextProps.currentRow === prevState.lastRow) &#123; return null; &#125; return &#123; lastRow: nextProps.currentRow, isCrollingDown: nextProps.curentRow &gt; prevState.lastRow &#125;&#125; 值得注意的事你需要定义初始state的值。无论是在constructor里，或者是类属性。否则会报警告。 这个方法getDerivedStateFromProps()会在第一次挂载和重绘的时候都会调用到，因此你基本不用在constructor里根据传入的props来setState。 如果定义了getDerivedStateFromProps后，又定义了componentWillReceiveProps。那么，只有前者会被调用，并且你会收到一个警告。 一般你会使用一个回调来保证某些代码实在state更新之后才被调用的。那么，请把这些代码都移到componentDidUpdate里。 如果你不喜欢使用static关键字，那么你可以这样： 调用这个方法和之前调用this.setState的效果是一样的。只会修改这些返回的值，如果是null的话则不修改state。state的其他值都会保留。 123ComponentName.getDerivedStateFromProps = (nextProps, prevState) =&gt; &#123; // Your code here&#125; Static Mode 严格模式是一个新的方式来确保你的代码是按照最佳实践开发的。它实际是一个在React.StrictMode下的组件。它可以用在你的组件树的任何一部分上。 123456789101112131415import &#123;StrictMode&#125; from 'react'class Application extends React.Component &#123; render() &#123; return ( &lt;StrictMode&gt; &lt;Context.Provider value=&#123;&#123;background: 'black', color: 'white'&#125;&#125;&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;Footer /&gt; &lt;/Context.Provider&gt; &lt;/StrictMode&gt; ); &#125;&#125; 如果一个在StricMode子树里的组件使用了componentWillMount方法，那么你会看到一个报错消息。 AsyncMode 异步模式在React.unsafe_AsyncMode下。使用AsncMode也会打开StrictMode模式下的警告。 如果你想学习更多异步模式的内容，你可以在下面的地方看到更多的文章和示例： https://build-mbfootjxoo.now.shhttps://github.com/koba04/react-fiber-resources 新版React Developer Tools 这个作者发文的时候居然是Firefox支持了最新版的React。而Chrome还木有。。。 原文地址：https://medium.com/@baphemot/whats-new-in-react-16-3-d2c9b7b6193b]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react native 问题汇总]]></title>
    <url>%2Freact-native-%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[目录 一、static getDerivedStateFromProps 二、16.3 生命周期相关改动 三、react native debug模式加载100%之后空白页 四、Module does not exist in the module map 五、ReactPropTypeLocations 找不到 六、Invariant Violation: Calling PropTypes validators directly is not supported by the prop-types package. Use PropTypes.checkPropTypes() to call them. 一、static getDerivedStateFromProps 作为被废弃的componentWillReceiveProps的替代，React提供了一个新的函数static getDerivedStateFromProps(nextProps, prevState) 注意前面的static，这意味着在这个函数中我们不能使用this, 该函数的返回值将用于更新state。如果不需要更新state，就返回null 1234static getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.text === prevState.text) return null; return &#123; text: nextProps.text &#125;; // 相当于setState(&#123; text: nextProps.text &#125;);&#125; 二、16.3 生命周期相关改动为了支持未来的异步渲染特性，以下生命周期函数将被废弃 componentWillMount 请使用 componentDidMount代替 componentWillUpdate 请使用 componentDidUpdate代替 componentWillReceiveProps 请使用新增的 static getDerivedStateFromProps代替废弃警告会在React 16.4开启，废弃的函数预计在React 17.0移除 123456789101112// componentWillMount 请使用 componentDidMount代替 替换实例componentWillUpdate(nextProps, nextState) &#123; foo(nextProps, nextState); bar(this.props, this.state); nextProps.a === this.props.a;&#125;componentDidUpdate(prevProps, prevState) &#123; foo(this.props, this.state); bar(prevProps, prevState); this.props.a === prevProps.a;&#125; 详细介绍请见：去哪儿.我爱你/React-16-3-新特性 三、react native debug模式加载100%之后空白页 “GET /debuggerWorker.js HTTP/1.1” 404 156 “http://localhost:8081/debugger-ui“ Downloading JavaScript bundle 100% &quot;GET /debuggerWorker.js HTTP/1.1&quot;的问题是由于我chrome的问题无法自动打开http://localhost:8081/debugger-ui的页面导致的。 Downloading JavaScript bundle 100%加载之后一直空白页尝试了多次一直都这样。最后我通过使用官方的react native debugger工具成功debug了 四、Module does not exist in the module map error: bundling failed: Error: Unable to resolve module react/lib/ReactPropTypeLocations from /Users/lee.guo/qunar.com/mobile/opsapp-rn/src/qrnControl/react-native-fence-html/HTMLStyles.js: Module does not exist in the module map 出现Module does not exist in the module map问题都是找不到module导致的， 检查下路径就能解决 五、ReactPropTypeLocations 找不到12// if (styleProps[key](testStyle, key, '', ReactPropTypeLocations.prop)) &#123;if (styleProps[key](testStyle, key, '', 'prop')) &#123; 六、Invariant Violation: Calling PropTypes validators directly is not supported by the prop-types package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types]]></content>
      <categories>
        <category>react native</category>
      </categories>
      <tags>
        <tag>RN</tag>
        <tag>react nateve</tag>
        <tag>debug</tag>
        <tag>debuggerWorker.js</tag>
        <tag>404</tag>
        <tag>bundle 100%</tag>
        <tag>debugger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python环境集成]]></title>
    <url>%2Fpython%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[目录 Centos6.5-nodejsv4.X-express 进入https://pypi.python.org/pypi/pip，下载第二项。 pip install virtualenv wget https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz\#md5\=35f01da33009719497f01a4ba69d63c9 --no-check-certificate tar -xf pip-9.0.1.tar.gz virtualenv .venv source .venv/bin/activate pip install -r requirements.txt -i http://devpi.corp.qunar.com/qunar/dev/+simple/ tools/with_venv.sh python setup.py install Centos6.5-nodejsv4.X-expressCentos6.5+nodejsv4.x+express的安装 很高兴第一次在github中写东西，以后我会多在这里边写东西的为什么我想要写这个Centos6.5+nodejsv4.x+express的安装呢？首先我接触nodejs在4月份，然后一直是在windows下使用nodejs+express的，windows我们很熟悉，也容易处理一些文件等等，但是我们工作的时候避免不了在linux下使用各种软件，这里不得不提到nodejs了，当然linux的的性能等等的优点我这里就不阐述了。 #下面进入正题：（PS：网上关于Centos6.5+nodejsv4.x+express确实也很多，但是我照着网上的教程搞了一天还是失败了而且还很麻烦，因为centos里的东西太老了，比如使用nodejs4.x以上就要升级gcc到4.8以上，这个我尝试了好多还是失败了，后来我差点绝望了，不过我发现了一个办法可以，在这里跟大家说一声，希望少走弯路）(注意：这里的所有操作都在root模式下) 1.安装centos6.5可以在虚拟机下安装 2.打开centos6.5，打开终端，在root模式下操作，root模式稍微说一下（su回车，然后输入密码即可） 3.获取nodejs 资源，这里有一下几种模式 4.x——————————curl –silent –location https://rpm.nodesource.com/setup_4.x | bash - 5.x——————————curl –silent –location https://rpm.nodesource.com/setup_5.x | bash - 0.10—————————–curl –silent –location https://rpm.nodesource.com/setup | bash - 我当然安装比较新的版本，4.X 在root模式下输入其中的一个 4.安装yum install -y nodejs 5.测试是否成功node -v 成功会返回版本号 下面可以安装express框架，具体express框架的作用自己谷歌一下 1.npm install express -g 不过express安装之后还要安装一下npm install -g express-generator 具体为什么可以自己去了解这里就不多说了 2.验证是否建立一个文件夹，然后express myblog 然后你们就应该都会了。。。。。。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX如何优雅的编码]]></title>
    <url>%2FLINUX%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[目录 oh-my-zsh zsh Linux shell zsh简介 zsh安装 取代bash，设为默认shell oh-my-zsh安装 oh-my-zsh主题 exz-conf GET CODE VIM CONFIG install updating usage oh-my-zshzshLinux shellLinux/Unix提供了很多种Shell，为毛要这么多Shell？ 难道用来炒着吃么？那我问你，你同类型的衣服怎么有那么多件？花色，质地还不一样。写程序比买衣服复杂多了，而且程序员往往负责把复杂的事情搞简单，简单的事情搞复杂。牛程序员看到不爽的Shell，就会自己重新写一套，慢慢形成了一些标准，常用的Shell有这么几种，sh、bash、csh等，想知道你的系统有几种shell，可以通过以下命令查看： cat /etc/shells 1234567[lee.guo@xxx.cn0 ~/qunar.com/qunar-backyard-v2]cat /etc/shells/bin/sh/bin/bash/sbin/nologin/bin/dash/bin/tcsh/bin/csh zsh简介Zsh是一个Linux下强大的shell, 由于大多数Linux产品安装，以及默认使用bash shell, 但是丝毫不影响极客们对zsh的热衷, 几乎每一款Linux产品都包含有zsh，通常可以用apt-get、urpmi或yum等包管理器进行安装 Zsh具有以下主要功能 开箱即用、可编程的命令行补全功能可以帮助用户输入各种参数以及选项 在用户启动的所有shell中共享命令历史 通过扩展的文件通配符，可以不利用外部命令达到find命令一般展开文件名 改进的变量与数组处理 在缓冲区中编辑多行命令 多种兼容模式，例如使用/bin/sh运行时可以伪装成Bourne shell 可以定制呈现形式的提示符；包括在屏幕右端显示信息，并在键入长命令时自动隐藏 可加载的模块，提供其他各种支持：完整的TCP与Unix域套接字控制，FTP客户端与扩充过的数学函数 完全可定制化 zsh安装sudo apt-get install zsh # Ubuntu sudo yum install zsh 取代bash，设为默认shellsudo usermod -s /bin/zsh exit oh-my-zsh安装直接用zsh会很蛋疼，因为zsh功能很强大但是太复杂，所以需要oh-my-zsh来将它简单化 直接用git从github上面下载包 git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 直接使用脚本安装 cd oh-my-zsh/tools ./install.sh 你可以直接直接使用如下命令安装 curl sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" wget sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" oh-my-zsh主题vim themes/robbyrussell.zsh-theme 替换内容 local ret_status="%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ )" # PROMPT='${ret_status} %{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)' PROMPT='%{$fg_bold[red]%}➜ %{$fg_bold[green]%}%p%{$fg[cyan]%}%d %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%}% %{$reset_color%}&gt;' ZSH_THEME_GIT_PROMPT_PREFIX="%{$fg_bold[blue]%}git:(%{$fg[red]%}" ZSH_THEME_GIT_PROMPT_SUFFIX="%{$reset_color%} " ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg[blue]%}) %{$fg[yellow]%}✗" ZSH_THEME_GIT_PROMPT_CLEAN="%{$fg[blue]%})" exz-conf vim 工具 GET CODE1234567CONFDIR=/home/lee.guoecho $CONFDIRcd $CONFDIRgit clone https://github.com/jaypei/exz-conf.gitcd exz-confgit submodule initgit submodule update VIM CONFIGinstallln -s $CONFDIR/exz-conf/vimconf/_vimrc ~/.vimrc ln -s $CONFDIR/exz-conf/vimconf/_gvimrc ~/.gvimrc ln -s $CONFDIR/exz-conf/vimconf/vimfiles ~/.vim # pylint ln -s $CONFDIR/exz-conf/vimconf/pylint.ini ~/.pylintrc updatingcd $CONFDIR/exz-conf git pull --rebase; git submodule update cd - usage 回车 等同于 : (normal) 空格 等同于 ,/ (normal) 0 等同于 ^ ，到行首字母前 (noarmal) Q 关闭文件 (normal) F4 or Shift+F4 切换 source/header (A) F5 or Shift+F5 语法静态检查 (SyntasticCheck) F8 or Shift+F8 VimWiki F11 or Shift+F11 tag list (tagbar) F12 or Shift+F12 目录树 (NERDTree) Ctrl+h 光标移进 左 侧分割窗 Ctrl+l 光标移进 右 侧分割窗 Ctrl+j 光标移进 下 侧分割窗 Ctrl+k 光标移进 上 侧分割窗 默认 leader key 已设置为 , 。 ,j 当前行下移 (normal) ,k 当前行上移 (normal) ,pp 切换paste和nopaste模式 ,m 设置当前位置单词高亮 ,n 取消当前位置单词高亮 ,/ 跳转到下一个高亮位置 ,c 清除所有高亮 ,s 删除所有行尾空白 ,, 保存文件，等同于 :w]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINUX磁盘空间查看]]></title>
    <url>%2FLINUX%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[目录 显示磁盘分区上的可使用的磁盘空间 语法 选项 参数 实例 对文件和目录磁盘使用的空间的查看 语法 选项 实例 附 清空大文件内容 显示磁盘分区上的可使用的磁盘空间df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法df(选项)(参数) 选项12345678910111213141516-a或--all：包含全部的文件系统；--block-size=&lt;区块大小&gt;：以指定的区块大小来显示区块数目；-h或--human-readable：以可读性较高的方式来显示信息；-H或--si：与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes；-i或--inodes：显示inode的信息；-k或--kilobytes：指定区块大小为1024字节；-l或--local：仅显示本地端的文件系统；-m或--megabytes：指定区块大小为1048576字节；--no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；-P或--portability：使用POSIX的输出格式；--sync：在取得磁盘使用信息前，先执行sync指令；-t&lt;文件系统类型&gt;或--type=&lt;文件系统类型&gt;：仅显示指定文件系统类型的磁盘信息；-T或--print-type：显示文件系统的类型；-x&lt;文件系统类型&gt;或--exclude-type=&lt;文件系统类型&gt;：不要显示指定文件系统类型的磁盘信息；--help：显示帮助；--version：显示版本信息。 参数文件：指定文件系统上的文件。 实例12345678[root@l-xxxx.xxs.cn2 /home/q]# df -hFilesystem Size Used Avail Use% Mounted on/dev/vda2 9.9G 1.5G 7.9G 16% /tmpfs 1.9G 12K 1.9G 1% /dev/shm/dev/vda1 194M 54M 131M 29% /boot/dev/vda6 985M 38M 897M 5% /home/dev/vda7 60G 48G 9.1G 85% /home/q/dev/vda5 4.0G 2.9G 953M 76% /var 对文件和目录磁盘使用的空间的查看du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。 语法du [选项][文件] 选项123456789101112131415-a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-k或--kilobytes 以KB(1024bytes)为单位输出。-m或--megabytes 以MB为单位输出。-s或--summarize 仅显示总计，只列出最后加总的值。-h或--human-readable 以K，M，G为单位，提高信息的可读性。-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。--exclude=&lt;目录或文件&gt; 略过指定的目录或文件。-D或--dereference-args 显示指定符号链接的源文件大小。-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。-l或--count-links 重复计算硬件链接的文件。 实例查看当前目录下总大小12[root@l-xxxx.xxx.xxx /home/q]# du -s49912968 . 查看当前目录下各文件及文件夹大小12345678910111213141516171819202122[root@l-xxx /home/q]# du -h --max-depth=1192K ./ops_deploy16K ./lost+found228K ./www7.0M ./collectd6.9M ./tomcat94M ./apache-flume-1.5.0-bin120M ./opsapp-tools279M ./java11M ./zeromq23M ./qagentcli994M ./qflume-ng16K ./salt46G ./var197M ./python2716K ./.code44K ./tools20K ./runit24K ./bds_deploy528K ./cache6.4M ./nrpe48G . 附清空大文件内容echo "" &gt; filename 以上资料均参考自linux命令大全]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN大版本升级 0.41 -> 0.51]]></title>
    <url>%2FRN%E5%A4%A7%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7-0-41-0-51%2F</url>
    <content type="text"><![CDATA[目录 前言 react native部分 修改package.json中react,react-native版本 根据react native 的changelog 修改不兼容的代码，同时需要注意用到的某些开源组件，是否对新版本兼容。修改不兼容的组件，升级/修改源码/重换组件 ios部分 前言 本来打算升级的时候RN最新版还是0.51，直到升级实施起来RN已经更新到0.53。 react native部分修改package.json中react,react-native版本1234"dependencies": &#123; "react": "^16.3.0-alpha.1", "react-native": "^0.54.0"&#125; 根据react native 的changelog 修改不兼容的代码，同时需要注意用到的某些开源组件，是否对新版本兼容。修改不兼容的组件，升级/修改源码/重换组件 react/lib/XXX 已没有123var ReactChildren = require('react/src/ReactChildren');修改为React.Children 12345var ReactPropTypes = require('react/src/ReactPropTypes');修改为import PropTypes from 'prop-types';PropTypes.XXXX react-native-fance-html 库修改12345// HTMLStyles.js// import ReactPropTypeLocations from 'react/lib/ReactPropTypeLocations'// if (styleProps[key](testStyle, key, '', ReactPropTypeLocations.prop)) &#123;if (styleProps[key](testStyle, key, '', 'prop')) &#123;&#125; ios部分 更新依赖, 修改react,react-native版本. rm -rf node_modules qnpm install pod install --no-repo-update 清理xcode/模拟器缓存 如果确认自己代码没问题，相关依赖也都正确，试试清空 watchman/模拟器/xcode 缓存，清理的时候，关闭npm start，模拟器，xcode 如果 pod install 报错 -bash: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory, 解决方案]]></content>
      <categories>
        <category>react native</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN升级遇到的坑]]></title>
    <url>%2FRN%E5%8D%87%E7%BA%A7%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[目录 找不到index入口 问题症状 处理方法 原因 prop-types 报错 症状 处理方案 代码引入 使用 原因 react-native 出现 No component found for view with name “RNSVG*” 症状 处理办法 Invariant Violation: Calling PropTypes validators directly is not supported by the prop-types package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types Invariant Violation: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. 处理方案 找不到index入口问题症状 RN找不到index入口 error: bundling failed: Error Cannot find entry file index.js in any of the roots 处理方法12将 index.android.js 重命名为 index.js然后把 index.ios.js 删除。 原因 0.49 版本最大的一个变化应该就是将两个平台的入口文件 index.android.js 与 index.ios.js 合并成了一个入口文件 index.js，但是 RN 并不会自动帮你完成这个改变，你需要自己完成这步操作. prop-types 报错症状 undefined is not an object 找不到PropTypes evaluating react2.PropTypes.string 处理方案1npm install --save prop-types 代码引入12import PropTypes from 'prop-types'; // ES6var PropTypes = require('prop-types'); // ES5 with npm 或者12345&lt;!-- development version --&gt;&lt;script src="https://unpkg.com/prop-types/prop-types.js"&gt;&lt;/script&gt;&lt;!-- production version --&gt;&lt;script src="https://unpkg.com/prop-types/prop-types.min.js"&gt;&lt;/script&gt; 使用下面例子仅供参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // 你可以将属性声明为以下 JS 原生类型 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何可被渲染的元素（包括数字、字符串、子元素或数组）。 optionalNode: PropTypes.node, // 一个 React 元素 optionalElement: PropTypes.element, // 你也可以声明属性为某个类的实例，这里使用 JS 的 // instanceof 操作符实现。 optionalMessage: PropTypes.instanceOf(Message), // 你也可以限制你的属性值是某个特定值之一 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 限制它为列举类型之一的对象 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 一个指定元素类型的数组 optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 一个指定类型的对象 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 一个指定属性及其类型的对象 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // 你也可以在任何 PropTypes 属性后面加上 `isRequired` // 后缀，这样如果这个属性父组件没有提供时，会打印警告信息 requiredFunc: PropTypes.func.isRequired, // 任意类型的数据 requiredAny: PropTypes.any.isRequired, // 你也可以指定一个自定义验证器。它应该在验证失败时返回 // 一个 Error 对象而不是 `console.warn` 或抛出异常。 // 不过在 `oneOfType` 中它不起作用。 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // 不过你可以提供一个自定义的 `arrayOf` 或 `objectOf` // 验证器，它应该在验证失败时返回一个 Error 对象。 它被用 // 于验证数组或对象的每个值。验证器前两个参数的第一个是数组 // 或对象本身，第二个是它们对应的键。 customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;; 原因从 React 16.0.0 开始，PropTypes 就已经不再由 React 提供了，而 fb 专门提供了 prop-types 模块，需要通过import PropTypes from ‘prop-types’来使用 PropTypes。0.48 版本的 RN 使用的是 16.0.0-alpha.12 版本的 React，alpha 版本还没有移除 PropTypes，所以之前项目不会有任何问题。而到了 0.49版本，自动将 React 升级到了 16.0.0-beta.5，这个版本已经移除了 React.PropTypes，所以再编译就会报错了，因为找不到 PropTypes 了。 react-native 出现 No component found for view with name “RNSVG*”症状 no component found for view with name ‘RNSVGPath’ 处理办法 ios解决方案: https://www.jianshu.com/p/b51b79ca14e7 Invariant Violation: Calling PropTypes validators directly is not supported by the prop-types package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types Invariant Violation: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object.处理方案&gt;123var HTML = require('react-native-htmlview');//改为import HTML from 'react-native-htmlview';]]></content>
      <categories>
        <category>react native</category>
      </categories>
      <tags>
        <tag>RN</tag>
        <tag>PropTypes.checkPropTypes</tag>
        <tag>prop-types</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react native 原生环境踩坑]]></title>
    <url>%2Freact-native-%E5%8E%9F%E7%94%9F%E7%8E%AF%E5%A2%83%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[目录 目录 1. IOS ‘MMMarkdown/MMMarkdown.h’ file not found 2. Unable to find a specification for SocketRocket 3. ‘ProtocolBuffers/ProtocolBuffers.h’ file not found 4. Caused by: java.lang.InstantiationError: okhttp3.internal.ws.RealWebSocket 解决办法 5. 华为手机无法允许usb调试 问题 处理方案 1. IOS ‘MMMarkdown/MMMarkdown.h’ file not found 苹果原生环境MMMarkdown找不到，需要安装carthage123brew install carthagecarthage update # 项目目录下执行open Untitled.xcworkspace/ 2. Unable to find a specification for SocketRocket xcodeproj was renamed to project. Please update your Podfile accordingly. 当在update或install时遇会到这个问题只需要把当前Pod的目录清理一下就行了。在终端执行以下命令： 123pod repo remove master pod setuppod install 3. ‘ProtocolBuffers/ProtocolBuffers.h’ file not found 没有Pod进去的原因，改为 #import "ProtocolBuffers.h" 4. Caused by: java.lang.InstantiationError: okhttp3.internal.ws.RealWebSocket 在安卓启动时候报错,导致启动时就直接崩溃 解决办法删除 compile &#39;com.squareup.okhttp3:okhttp-ws:3.4.2&#39;升级到最新版 5. 华为手机无法允许usb调试问题 有应用遮挡了权限请求界面，所有辅助功能设置都提示前面 处理方案 关掉护眼模式跟悬浮导航就可以 此文章只作为遇到问题的记录，如有相似问题请结合项目进行参考。]]></content>
      <categories>
        <category>react native</category>
      </categories>
      <tags>
        <tag>RN</tag>
        <tag>native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react native 安卓真机开发者模式]]></title>
    <url>%2Freact-native-%E5%AE%89%E5%8D%93%E7%9C%9F%E6%9C%BA%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[目录 踩坑 准备 你需要开启USB调试才能在你的设备上安装你的APP。首先，确定你已经打开设备的USB调试开关 确保手机电脑连接同一WiFi 手机已打开可出现在顶部的应用程序权限 [注意] android中setUseDeveloperSupport为true 摇晃设备，打开开发者菜单。 后话 踩坑 安卓真机调试，摇一摇无法唤醒开发菜单 react native 安卓无法打开开发者菜单 react native无法调试 安卓开发者模式出不来 准备你需要开启USB调试才能在你的设备上安装你的APP。首先，确定你已经打开设备的USB调试开关确保手机电脑连接同一WiFi手机已打开可出现在顶部的应用程序权限各个手机设置方法不一致，以三星s6为例设置 --&gt; 应用程序 --&gt; [对应的程序] --&gt; 高级设置(出现在顶部的应用程序) [注意] android中setUseDeveloperSupport为true123456789101112public static ReactInstanceManager buildBundle(Activity activity, String register, String bundle)&#123; return ReactInstanceManager.builder() .setApplication(activity.getApplication()) .setJSBundleFile(getLocalBundlePath(activity) + bundle) .setJSMainModuleName("index.android") .addPackage(new MainReactPackage()) .addPackage(new StoreReactPackage()) .setUseDeveloperSupport(CommonConfig.isDebug) //这里必须设置成true .setInitialLifecycleState(LifecycleState.RESUMED) .build(); &#125;; 摇晃设备，打开开发者菜单。Dev Settings --&gt; Debug server host for device --&gt; 输入你电脑的IP地址和端口号 后话至此全部准备工作完成，开始你愉快的RN开发旅程吧。 如有什么疑问欢迎下方留言。]]></content>
      <categories>
        <category>react native</category>
      </categories>
      <tags>
        <tag>RN</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript学习笔记(一)]]></title>
    <url>%2FECMAScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录 ECMAScript 学习笔记（一） 函数调用中使用展开运算符 用于解构赋值 ES7对象展开运算符 类数组对象变成数组(Array.from()) 错误示范 正确示范 ECMAScript 学习笔记（一） es6标准的制定为javascript添加了很多新特性,今天主要说一下展开运算符。 函数调用中使用展开运算符es6之前：123function test(a, b, c) &#123; &#125;var args = [0, 1, 2];test.apply(null, args);//数组展开成多个参数 es6之后，利用es6的展开运算符这一新特性，简化了代码书写:123function test(a,b,c) &#123; &#125;var args = [0,1,2];test(...args); 用于解构赋值123456let [arg1,arg2,...arg3] = [1, 2, 3, 4];arg1 //1arg2 //2arg3 //['3','4']/* 注意： 解构赋值中展开运算符必须放在最后，不然会报错！！！*/ ES7对象展开运算符偶然发现对象还可以有这种操作，跟数组展开运算符大同小异，很方便啊~~123456789101112131415//解构赋值let &#123;x,y,...z&#125;=&#123;x:1,y:2,a:3,b:4&#125;;x; //1y; //2z; //&#123;a:3,b:4&#125;// 直接插值let a=&#123;x:1&#125;;let b=&#123;y:1,z:1,...a&#125;;//对象合并let a=&#123;x:1&#125;;let b=&#123;y:1&#125;;let c=&#123;...a,...b&#125;;c; //&#123;x:1,y:1&#125; 类数组对象变成数组(Array.from())一开始对类数组对象的认识比较模糊，特地了解了一下什么是类数组对象，对于类数组对象的解释和大家说一下： 关于类数组对象的介绍：JavaScript中有一些看起来像却又不是数组的对象，叫做类数组。简单举个例子：1let t=&#123;0:52,1:63,2:4,length:3&#125;; 我理解的简单一点，首先它必须是一个对象类型，其次对象内部的key表示的是当前的索引值，以及length 属性告诉我们对象的元素个数. 类数组对象自身不具有push、forEach、indexOf等数组对象对应的方法。 这里es6新特性对于类数组对象转化为数组，提供了更简便的方法。es6之前：123let t=&#123;0:52,1:63,2:4,length:3&#125;;let arr=[].slice.call(t);console.log(arr) // [52, 63, 4] es6之后：12let t=&#123;0:52,1:63,2:4,length:3&#125;;let d=Array.from(t); // [52, 63, 4] 错误示范12let t=&#123;0:52,1:63,2:4,length:3&#125;;let arr=[...t];// 这种写法是错误的，类数组对象明确定义不能直接使用数组对象的方法。只有展开对象是可遍历的情况下可以这样写。 正确示范123var tr=&#123;x:52,y:63,z:4&#125;;//展开对象可遍历var arr=[...d];arr；// [52, 63, 4] 本文只是对es6展开运算符做了简单介绍，如有写不对的地方，欢迎指正！ 参考文章链接：ECMAScript 6学习笔记（一）：展开运算符]]></content>
      <categories>
        <category>javascrip</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react native样式整理]]></title>
    <url>%2Freact-native%E6%A0%B7%E5%BC%8F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[目录 react native 样式表整理 Flexbox布局样式 react native 样式表整理 整理下rn的常用样式，供新手参考： Flexbox布局样式 样式名称 k v 解释 项目对齐 alignItems flex-startflex-endcenterstretch 自身对齐 alignSelf flex-startflex-endcenterautostretch flex-start：与父容器首部对齐flex-end:与父容器尾部对齐 center：位于垂直位置auto：按照自身设置的宽高来显示，如果没设置，效果跟streth一样stretch：垂直拉伸 该属性通过定义flex容器的主轴方向来决定felx子项在flex容器中的位置。这将决定flex需要如何进行排列 flexDirection rowrow-reversecolumncolumn-reverse row：主轴与行内轴方向作为默认的书写模式。即横向从左到右排列（左对齐）。row-reverse：对齐方式与row相反column：主轴与块轴方向作为默认的书写模式。即纵向从上往下排列（顶对齐）column-reverse：对齐方式与column相反。]]></content>
      <categories>
        <category>react native</category>
      </categories>
      <tags>
        <tag>RN</tag>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用D3实现伪3D效果金字塔]]></title>
    <url>%2F%E7%94%A8d3%E5%AE%9E%E7%8E%B0%E4%BC%AA3d%E6%95%88%E6%9E%9C%E9%87%91%E5%AD%97%E5%A1%94%2F</url>
    <content type="text"><![CDATA[目录 用d3实现金字塔伪3d效果 定义图表需要的数据结构 创建svg 生成金字塔 调用函数方法并传参 用d3实现金字塔伪3d效果 工作中偶然接触到d3，慢慢开始熟悉d3，并可以根据效果图进行图形绘制，要完全掌握d3绘图技巧需要不断深入学习研究，今天要展示的是我遇到的一个类似3d效果的金字塔效果图，其实是个伪3d，由于本人学术不精，只想到利用path拼接面的形式来实现（其实一开始想研究研究threejs，but needtime,so…),废话不多说，绘制过程代码如下： 定义图表需要的数据结构1234567891011121314151617181920212223 /*植被类型*/let vegetation_type = ['人工林', '沼泽', '常绿阔叶灌丛', '灌草丛', '红树林'];/*金字塔每层颜色*/let vegetation_color = [&#123; startColor: '#077cec', endColor: '#126fbf'&#125;, &#123; startColor: '#2c6cff', endColor: '#2783df'&#125;, &#123; startColor: '#628eff', endColor: '#2d74cc'&#125;, &#123; startColor: '#60e9e9', endColor: '#46b7b3'&#125;, &#123; startColor: '#fffe2c', endColor: '#fffe2c'&#125;];/*定义金字塔最大宽度*/let w_pyramid_max = 148;/*定义金字塔最大高度*/let h_pyramid_max = 138; 创建svg1234let svg = d3.select('#pyramid') .append('svg') .attr('width', 400) .attr('height', 400); 生成金字塔1234567891011121314151617181920function CreatePyramid(tra_x, tra_y, startColor, endColor, path_bot, path_ins) &#123; let set_path_ins=path_ins||''; let g_contain = svg.append('g') .attr('transform', 'translate(' + tra_x + ',' + tra_y + ')'); let g_bottom = g_contain.append('g') .attr('transform', 'translate(0,0)'); let path_bottom = g_bottom.append('path') .attr('d', function() &#123; return path_bot; &#125;) .attr('fill', startColor); // .attr('stroke', '#3ed8fb'); let g_inside = g_contain.append('g') .attr('transform', 'translate(0,0)'); let path_inside = g_inside.append('path') .attr('d', function() &#123; return set_path_ins; &#125;) .attr('fill', endColor);&#125;; 调用函数方法并传参123456789101112131415161718192021222324252627282930let [axis_a,axis_b,axis_c,axis_d]=[[],[],[],[]];//外层坐标点let [axisIn_a,axisIn_b,axisIn_c,axisIn_d]=[[],[],[],[]];//内层坐标点//循环5组数据，调用函数方法并赋值vegetation_type.map((t, i) =&gt; &#123; let tra_x = 100; //x轴偏移量 let tra_y = 100 - i * 26; //y轴偏移量 let startColor = vegetation_color[i].startColor; //外层颜色 let endColor = vegetation_color[i].endColor; //内层颜色 //外层4个坐标点 axis_a=[12.8*(i+1),118]; axis_b=[14.8*i,138]; axis_c=[w_pyramid_max-14.8*i,h_pyramid_max]; axis_d=[w_pyramid_max-12.8*(i+1),118]; //里层4个坐标点 axisIn_a=[axis_a[0]+6,112]; axisIn_b=[axis_a[0],118]; axisIn_c=[w_pyramid_max-axis_a[0],118] axisIn_d=[148-axis_a[0]-6*(i+1),112]; if(i===4)&#123; //最顶层 let path_bot = 'M'+w_pyramid_max/2+','+108+'L'+axis_b[0]+','+axis_b[1]+'L'+90+','+axis_c[1]+' Z'; CreatePyramid(tra_x, tra_y, startColor, endColor,path_bot); &#125;else&#123; let path_bot = 'M'+axis_a[0]+','+axis_a[1]+'L'+axis_b[0]+','+axis_b[1]+'L'+axis_c[0]+','+axis_c[1]+'L'+axis_d[0]+','+axis_d[1]+' Z'; let path_ins = 'M'+axisIn_a[0]+','+axisIn_a[1]+'L'+axisIn_b[0]+','+axisIn_b[1]+'L'+axisIn_c[0]+','+axisIn_c[1]+'L'+axisIn_d[0]+','+axisIn_d[1]+' Z'; CreatePyramid(tra_x, tra_y, startColor, endColor,path_bot,path_ins); &#125; &#125;); 点击跳转Demo 最终效果呈现：]]></content>
      <categories>
        <category>D3</category>
      </categories>
      <tags>
        <tag>D3</tag>
        <tag>金字塔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小李面试总结1001篇 - 0001]]></title>
    <url>%2F%E5%B0%8F%E6%9D%8E%E7%9A%84%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%930001%2F</url>
    <content type="text"><![CDATA[目录 发布到线上的版本发现问题，git回滚怎么实现？ react什么情况会触发页面重新渲染 react-router了解多少，怎么实现路由页面的切换 svg画过图吗，举例说明怎么实现，svg画一条线，外面传进来的数据怎么与path路径映射。 webpack怎么实现线上版本发布 和本地代码分离，webpack配置项怎么配置 第一步，分别设置不同的接口地址 第二部，在代码中调用设置好的参数 用过redux吗 发布到线上的版本发现问题，git回滚怎么实现？ 远程分支回滚的三种办法： 方法一： revert1234git revert HEAD //撤销最近一次提交git revert HEAD~1 //撤销上上次的提交，注意：数字从0开始git revert 0ffaacc //撤销0ffaacc这次提交git push origin master 方法二： reset （不推荐， 不尊重历史记录）123// reset是指将当前head的内容重置，不会留任何痕迹。git reset --hard HEAD^git push origin master -f 注意，revert和reset的区别: revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在. reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。 关于远程仓库回滚 首先，必须要明白的一件事，任何普通用户不能擅自做有关远程仓库回退的操作，如果你擅自回滚了远程仓库，会对项目团队其他人造成不可预知的影响。如果需要回退版本，先联系项目的仓库管理员，在团队其他人都对自己本地未提交的工作做好备份之后，再进行远程仓库回退操作，操作结束后，团队成员需要重新同步远程仓库后继续自己的工作。 react什么情况会触发页面重新渲染 &emsp; 参考链接： React组件生命周期小结 首次加载 setState改变组件内部state 接收到新的props react-router了解多少，怎么实现路由页面的切换 svg画过图吗，举例说明怎么实现，svg画一条线，外面传进来的数据怎么与path路径映射。 webpack怎么实现线上版本发布 和本地代码分离，webpack配置项怎么配置 第一步，分别设置不同的接口地址分别创建下面的两个文件：12/config/dev.env.js/config/prod.env.js 这两个文件就是针对生产环境和发布环境设置不同参数的文件。我们打开dev.en.js文件。代码如下： 123456var merge = require('webpack-merge')var prodEnv = require('./prod.env')module.exports = merge(prodEnv, &#123; NODE_ENV: '"development"'&#125;) 在NODE_ENV下面增加一项，代码如下： 1234567var merge = require('webpack-merge')var prodEnv = require('./prod.env')module.exports = merge(prodEnv, &#123; NODE_ENV: '"development"', API_ROOT: '"//192.168.1.8/api"'&#125;) 编辑prod.env.js文件 1234module.exports = &#123; NODE_ENV: '"production"', API_ROOT: '"//www.baidu.com/api"'&#125; 在经过这样的配置之后，我们在运行 12npm run dev //测试环境npm run build //打包项目的时候，打包的是服务器正式接口 第二部，在代码中调用设置好的参数打开src/config/api.js文件，将原来开头的代码 12// 配置API接口地址var root = 'https://cnodejs.org/api/v1' 修改为12// 配置API接口地址var root = process.env.API_ROOT 用过redux吗 Redux的官网中用一句话来说明Redux是什么: Redux是针对JavaScript应用的可预测状态容器 redux 使用场景 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据 从组件角度： 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。 总之，不要把 Redux 当作万灵丹，如果你的应用没那么复杂，就没必要用它。另一方面，Redux 只是 Web 架构的一种解决方案，也可以选择其他方案。 redux文档-阮一峰Redux简介-慕课网]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>react</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[雪落无绪，梨花弄雨，美丽的相遇，春风依依。淡淡的年华似水，流逝的思念，没有谁不想走出爱的荆棘。 一段感情的浓浓蜜意，只是为失落做了更深的苦凄，不是守不住颜花玫丽；因为风，因为雨，因为有太多的折磨经历。多想与你共谋岁月，同渡一生，只是你的影袂已在千里之外，相隔山水重重。一个人走在冷冷风中，雪花飘飘如梦，痴想着守护今生，不要有什么海誓山盟，那不过是离别的誓词，为岁月中的相思留下满心的惆怅。春色撩人，春花茵茵，盛开的春景中遗落了爱的脚步。流水无情，情书难诉，其实水在洗涤着落香，失落的爱情。 你走了，你走向天涯的远方，没有音信，盼不到归期。鸿雁常飞，轮回秋月，收割者收去了季节的金黄，只余下空空荡荡的旷野，稀稀落落的残梦。天空蓝的莫名，白云轻轻，不要惊扰了思念，不要安慰孤独的心灵。感不到温暖，饮一壶老酒，燃烧胸膛，不去熄灭爱的征程。 听风的私语，听雨的悲泣，听不见呼唤的声音，无法走近心的距离。明月圆了，思念瘦了，总是在黎明前疲惫的睡去。阳光明媚，却针刺般痛，其实是无法调节自己的心情，关闭窗棂，任黑暗蔓延。 太久的时日，太久的孤单，内心深处依旧向往着，有一天你能突然出现，不在让一颗心永远沁泡在冰冷的深渊。宽阔的海岸正在被疯狂的浪吞噬，浩瀚的辽原只有一束大漠孤烟。一个旅行者，你的生命会在这荒凉里残喘吗？不，你等待吧！还有柔和的秋风，夕阳的璀璨。 你已经远走，留下一个梦，一个让人日夜的思念。都有谁一生为爱风雨兼程，又有谁能走过心中爱的渡口，跋涉追求需要一个爱的理由。若你远走只是为了邂逅，不如剪断最初的信守。你已经远走，离别时泪水流，那才是爱的语言。思程程，念漫漫，相思犹自长哀叹。 彼岸花开，空留牵念，山水有相逢，爱渐行渐远，思终结了爱恨情缘，在叶落失眠的夜，抽出一封封曾经灌满爱情的信笺，读过了午夜，感动了黎明。 素描菊淡，清香袭婉，你守望着凝练的深秋。天蓝蓝，遮拙疏影间飘零的衣衫，绣红的胸膛，北风吹老了灿烂。期语无寄，妥协给了生活，爱却不能放下。也许那是一个永远无法弥补的残局，你下了一半，不再落子，成为勾人心弦的悬念。 时光的河流轻轻淌过，凡世的纯美开不了天长地久。如果你曾经拥有，请珍惜，也许今生今世无缘在续。花泥往事，烟雨悠悠，蹒跚步履，白发拂风；真的爱，爱的真，婉约的故事多少伤情。 来了去了，穿越你的世界，读懂的人痴迷进去，流念停泊。春天，漫山的杏花浓郁芳香，只是品尝了酸涩的果子。 渡口斑驳的记忆中，思念成为涌动的潮流。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>乱写</tag>
      </tags>
  </entry>
</search>
